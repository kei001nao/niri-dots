// Animation Section

animations {
  workspace-switch {
    spring damping-ratio=0.80 stiffness=523 epsilon=0.0001
    //spring damping-ratio=1.0 stiffness=300 epsilon=0.0001
    // duration-ms 500
    // curve "cubic-bezier" 0.05 0.9 0.1 1.0
  }

  window-open {
    duration-ms 600
    curve "ease-out-quad"
    custom-shader "
    vec4 open_color(vec3 coords_geo, vec3 size_geo) {
      float progress = niri_clamped_progress;

      // Completely random angle (0 to 2*PI)
      float random_angle = niri_random_seed * 6.28318;

      // Rotate the coordinates to create tilted ribbons
      vec2 coords = coords_geo.xy - 0.5;
      float cos_a = cos(random_angle);
      float sin_a = sin(random_angle);
      vec2 rotated = vec2(
        coords.x * cos_a - coords.y * sin_a,
        coords.x * sin_a + coords.y * cos_a
      );

      // Now work with rotated Y position for ribbon indexing
      float y_pos = rotated.y + 0.5;

      // Equal-sized ribbons (20 total)
      float ribbon_count = 20.0;
      float ribbon_index = floor(y_pos * ribbon_count);

      // Alternating pattern: even = left, odd = right
      float direction = mod(ribbon_index, 2.0) == 0.0 ? -1.0 : 1.0;

      // Cascading delay
      float delay = ribbon_index / ribbon_count * 0.5;
      float ribbon_progress = clamp((progress - delay) / (1.0 - delay), 0.0, 1.0);

      // Slide along the rotated X axis
      rotated.x += (1.0 - ribbon_progress) * direction * 2.0;

      // Rotate back to get final coordinates
      coords = vec2(
        rotated.x * cos_a + rotated.y * sin_a,
        -rotated.x * sin_a + rotated.y * cos_a
      );
      coords += 0.5;

      // Regular sampling
      vec3 coords_tex = niri_geo_to_tex * vec3(coords.x, coords.y, 1.0);
      vec4 color = texture2D(niri_tex, coords_tex.xy);

      // Check if ribbon hasn't arrived yet
      if (coords.x < 0.0 || coords.x > 1.0) {
        return vec4(0.0);
      }

      return color;
    }"
  }

  window-close {
    duration-ms 500
    curve "linear"
    custom-shader r"
    vec4 fall_and_rotate(vec3 coords_geo, vec3 size_geo) {
      float progress = niri_clamped_progress * niri_clamped_progress;
      vec2 coords = (coords_geo.xy - vec2(0.5, 1.0)) * size_geo.xy;
      coords.y -= progress * 1440.0;
      float random = (niri_random_seed - 0.5) / 2.0;
      random = sign(random) - random;
      float max_angle = 0.5 * random;
      float angle = progress * max_angle;
      mat2 rotate = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
      coords = rotate * coords;
      coords_geo = vec3(coords / size_geo.xy + vec2(0.5, 1.0), 1.0);
      vec3 coords_tex = niri_geo_to_tex * coords_geo;
      vec4 color = texture2D(niri_tex, coords_tex.st);

      return color;
    }
    vec4 close_color(vec3 coords_geo, vec3 size_geo) {
      return fall_and_rotate(coords_geo, size_geo);
    }"
  }
  horizontal-view-movement {
    spring damping-ratio=1.0 stiffness=300 epsilon=0.0001
    // duration-ms 600
    // curve "ease-out-expo"
  }
  window-movement {
    spring damping-ratio=1.0 stiffness=300 epsilon=0.0001
    // duration-ms 600
    // curve "ease-out-expo"
  }
  window-resize {
    spring damping-ratio=1.0 stiffness=300 epsilon=0.0001
    // duration-ms 600
    // curve "ease-out-expo"
  }
  overview-open-close {
    spring damping-ratio=1.0 stiffness=600 epsilon=0.0001
  }
}

